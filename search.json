[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rolling Dice with R",
    "section": "",
    "text": "About\n\n\n\n\n\nIn this manuscript I describe a couple of examples for implementing simulations of games of chance in R.\n\nAbout You\nI am assuming that you have some experience working with R. I’m also assuming that you have both R or RStudio installed in your computer. If this is not the case, you can take a look at Breaking the Ice with R\nhttps://www.gastonsanchez.com/R-ice-breaker\n\n\nCitation\nYou can cite this work as:\nSanchez, G. (2022) Rolling Dice with R: Exploring Simulations in Games of Chance with R.  https://www.gastonsanchez.com/R-rolling-dice\n\n\n\nMy Series of R Tutorials\nThis document is part of a series of texts that I’ve written about Programming and Data Analysis in R:\n\nBreaking the Ice with R: Getting Started with R and RStudio  https://www.gastonsanchez.com/R-ice-breaker\nTidy Hurricanes: Analyzing Tropical Storms with Tidyverse Tools  https://www.gastonsanchez.com/R-tidy-hurricanes\nR Coding Basics: An Introduction to the Basics of Coding in R  https://www.gastonsanchez.com/R-coding-basics\nRolling Dice: Exploring Simulations in Games of Chance with R  https://www.gastonsanchez.com/R-rolling-dice\nR for Strings: Handling Strings with R  https://www.gastonsanchez.com/R-for-strings\nWeb Technologies in R: A Short Introduction to Web Technologies in R  https://www.gastonsanchez.com/R-web-technologies\n\n\n\n\nDonation\nAs a Data Science and Statistics educator, I love to share the work I do. Each month I spend dozens of hours curating learning materials like this resource. If you find any value and usefulness in it, please consider making a one-time donation—via paypal—in any amount (e.g. the amount you would spend inviting me a cup of coffee or any other drink). Your support really matters.\n\n\n\nLicense\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License."
  },
  {
    "objectID": "01-intro.html",
    "href": "01-intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "We are going to use a classic example in the history of probability: the problem posed by French gambler Antoine Gombaud (1607-1684), better known by his nome de plume “Chevalier De Méré”. By the way, he was not a nobleman, but just an amateur mathematician. Most important, for the history of mathematics and probability, he was an avid gambler.\nSpecifically, let’s focus on one type of gambling scenario which we will refer to as “Game-A”"
  },
  {
    "objectID": "01-intro.html#description-of-game-a",
    "href": "01-intro.html#description-of-game-a",
    "title": "1  Introduction",
    "section": "1.1 Description of Game-A",
    "text": "1.1 Description of Game-A\nThis is a fairly simple game of dice in which you roll a die four times, and you win if you get at least one six.\n\n\n\n\n\nFigure 1.2: Rolling 4 dice in Game version A\n\n\nThink about what could happen when rolling one die four times. For instance, some possible outcomes may be:\n\n1, 3, 5, 2 (you lose)\n2, 4, 6, 5 (you win)\n5, 6, 3, 6 (you win)\n4, 2, 1, 3 (you lose)\n1, 3, 5, 2 (you win)\n\n\nThis is how De Méré was reasoning about Game-A:\n\nthe chance of getting a six in one roll of a die is 1/6 (this is correct)\nin four rolls of a die, the chance of getting one six would be \\(4 \\times 1/6 = 4/6 = 2/3\\) (this is incorrect)\n\nBased on this (incorrect) reasoning, he assumed that the odds were definitely in his favor. Interestingly, despite De Méré’s faulty reasoning about the probability of getting one six in four rolls, he was able to make money by playing this game.\nWhy was he able to make money? Let’s find out the probability of winning in this type of game."
  },
  {
    "objectID": "01-intro.html#probability-of-winning-game-a",
    "href": "01-intro.html#probability-of-winning-game-a",
    "title": "1  Introduction",
    "section": "1.2 Probability of winning Game-A",
    "text": "1.2 Probability of winning Game-A\nFinding the probability of winning Game-A translates into finding the probability of getting at least one six in four rolls of a (fair) die:\n\\[\nProb(\\text{winning Game-A}) = Prob(\\text{getting at least one 6 in four rolls})\n\\]\nThis probability can easily be calculated with the complement probability rule which states that:\n\nthe probability of one event is equal to 1 minus the probability of its complement event.\n\nOr in symbols:\n\\[\nProb(\\text{E}) = 1 - Prob(\\text{Not E})\n\\]\nand equivalently:\n\\[\nProb(\\text{Not E}) = 1 - Prob(\\text{E})\n\\]\nwhere:\n\n\\(\\text{E}\\) and \\(\\text{Not E}\\) are complement events (i.e. they cannot occur simultaneously)\n\nA classic example of this type of complement events is “E = getting heads when flipping a coin” and “Not E = getting tails when flipping a coin”.\n\\[\nProb(\\text{getting heads}) = 1 - Prob(\\text{getting tails}) \\\\\n\\]\nand\n\\[\nProb(\\text{getting tails}) = 1 - Prob(\\text{getting heads})\n\\]\n\nSo, if we consider event “E = getting at least one six in four rolls”, then its complement event is “Not E = getting no six in four rolls”\n\n1.2.1 No six in four rolls\nThe probability of getting no six in four rolls involves not getting a six in the first roll, AND not getting a six in the second roll, AND not getting a six in the third roll, AND not getting a six in the fourth roll. Because each roll is independent from the others, we can express this probability as the product of the probability in each roll:\n\\[\nProb(\\text{no 6 in 4 rolls}) = Prob(\\text{no 6 in 1st roll}) \\times \\dots \\times Prob(\\text{no 6 in 4th roll})\n\\]\nIn any single roll, the probability of getting no six is:\n\\[\nProb(\\text{no six in one roll}) = \\frac{5}{6}\n\\]\nTherefore:\n\\[\\begin{align*}\nProb(\\text{no six in 4 rolls}) &= Prob(\\text{no 6 in 1st roll}) \\times \\dots \\times Prob(\\text{no 6 in 4th roll}) \\\\\n&= \\frac{5}{6} \\times \\frac{5}{6} \\times \\frac{5}{6} \\times \\frac{5}{6} \\\\\n&= \\left( \\frac{5}{6} \\right)^4 \\\\\n&= \\frac{625}{1296} = 0.482253\n\\end{align*}\\]\nConsequently, the probability of winning Game-A is:\n\\[\\begin{align*}\nProb(\\text{at least one six in 4 rolls}) &= 1 - Prob(\\text{no six in 4 rolls}) \\\\\n&= 1 - \\left( \\frac{5}{6} \\right)^4 \\\\\n&= 0.517747\n\\end{align*}\\]\nNote that this probability of 0.517747 is not that much different from 0.5 (just slightly greater). But the difference is enough so that if you gamble in this game, you should expect to have a positive gain … in the long run."
  },
  {
    "objectID": "02-playing-game1.html",
    "href": "02-playing-game1.html",
    "title": "2  Coding Game-A",
    "section": "",
    "text": "In the preceding chapter we described Game-A, and we were able to derive the probability of winning this game:\n\\[\\begin{align*}\nProb(\\text{at least one six in 4 rolls}) &= 1 - Prob(\\text{no six in 4 rolls}) \\\\\n&= 1 - \\left( \\frac{5}{6} \\right)^4 \\\\\n&= 0.517747\n\\end{align*}\\]\nIn this example, we are able to find the exact probability associated to the event of “winning Game-A”. However, not all probability problems have an analytical solution. When this is the case, we often rely on computers to implement simulations that allow us to find an approximate solution, and have a better understanding of the systematic long-term patterns that arise in random processes.\nTo go ahead with our exploration of simulations, let us pretend that the probability of winning Game-A had no analytical solution. Instead, let’s see how to use R for running various simulations to get an idea of the probabilities involved behind Game-A."
  },
  {
    "objectID": "02-playing-game1.html#rolling-one-die",
    "href": "02-playing-game1.html#rolling-one-die",
    "title": "2  Coding Game-A",
    "section": "2.1 Rolling one die",
    "text": "2.1 Rolling one die\nBecause Game-A involves rolling a die four times, the first step is to create—in a computational sense—an object die, and learn how to roll it.\nPerhaps the most straightforward way to create a die object is with a numeric vector. One option for this is with a numeric sequence as follows:\n\ndie = 1:6\n\ndie\n\n[1] 1 2 3 4 5 6\n\n\nOnce we have an object die, how do we roll it? Rolling a die, computationally speaking, implies getting a sample of size 1 from the elements in vector die. To do this in R, we can use the function sample(). This function takes an input vector and draws a random sample—of a given size—from the vector’s elements.\n\n# random seed (for reproducibility purposes)\nset.seed(5)\nsample(die, size = 1)\n\n[1] 2\n\n\nBecause sample() is a function that generates random numbers, every time you invoke it you will get a different output.\n\n# another \"roll\"\nsample(die, size = 1)\n\n[1] 3\n\n\n\n# one more \"roll\"\nsample(die, size = 1)\n\n[1] 1\n\n\nTo be able to reproduce results with any random generator function, you can use set.seed() to set the so-called random seed that the algorithms behind sample() and friends employ to generate those values. By setting this seed, you can obtain the same reproducible output:\n\n# random seed (for reproducibility purposes)\nset.seed(5)\nsample(die, size = 1)\n\n[1] 2"
  },
  {
    "objectID": "02-playing-game1.html#rolling-dice-with-sample",
    "href": "02-playing-game1.html#rolling-dice-with-sample",
    "title": "2  Coding Game-A",
    "section": "2.2 Rolling dice with sample()",
    "text": "2.2 Rolling dice with sample()\nWhat about rolling a pair of dice? We could repeat the sample() command twice:\n\nset.seed(5)\nroll1 = sample(die, size = 1)\nroll2 = sample(die, size = 1)\n\nTo avoid repeating the sample() command multiple times we can also change the value of the size argument in sample():\n\nset.seed(5)\nsample(die, size = 2)\n\n[1] 2 3\n\n\nThe issue, not evident here, is that sample()–by default—draws samples without replacement. This means that if we want to get a sample of size six, we would get a simple rearrangement of the elements in die, which may not be what we really want:\n\nset.seed(5)\nsample(die, size = 6)\n\n[1] 2 3 1 5 4 6\n\n\nEven worse, for bigger samples of size 7 or greater, we would run into some limitations:\n\nset.seed(5)\nsample(die, size = 7)\n\nError in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when 'replace = FALSE'\n\n\nSo, how do we draw samples with replacement? To draw samples with replacement we need to use the replace argument as follows:\n\nset.seed(5)\nsample(die, size = 2, replace = TRUE)\n\n[1] 2 3"
  },
  {
    "objectID": "02-playing-game1.html#rolling-four-dice",
    "href": "02-playing-game1.html#rolling-four-dice",
    "title": "2  Coding Game-A",
    "section": "2.3 Rolling four dice",
    "text": "2.3 Rolling four dice\nSo far, so good. We have a mechanism to simulate rolling a die four times:\n\nset.seed(20)\nfour_rolls = sample(die, size = 4, replace = TRUE)\nfour_rolls\n\n[1] 6 3 2 1\n\n\nWith an output vector of four rolls, the next step involves determining if any of the numbers is a six. To do this, we use a comparison to see which elements in four_rolls are equal to 6:\n\nfour_rolls == 6\n\n[1]  TRUE FALSE FALSE FALSE\n\n\nThis comparison returns a logical vector, which we can then pass to sum() in order to count the number of TRUE values:\n\ncount_sixes = sum(four_rolls == 6)\ncount_sixes\n\n[1] 1\n\n\nBecause all we care about is knowing if there’s at least one six, we can also use the any() function; here are a couple of examples of what this function does when testing equality to 6:\n\nany(c(6, 3, 2, 1) == 6)\n\n[1] TRUE\n\nany(c(5, 3, 2, 1) == 6)\n\n[1] FALSE\n\nany(c(4, 6, 2, 6) == 6)\n\n[1] TRUE\n\n\nIf any() returns TRUE, we win that game. If it returns FALSE, we lose."
  },
  {
    "objectID": "02-playing-game1.html#playing-game-a-once",
    "href": "02-playing-game1.html#playing-game-a-once",
    "title": "2  Coding Game-A",
    "section": "2.4 Playing Game-A once",
    "text": "2.4 Playing Game-A once\nTo summarize, here’s some code that allows us to play Game-A once, determining the winning status:\n\n# playing Game-A once\nset.seed(20)\nfour_rolls = sample(die, size = 4, replace = TRUE)\nwin = any(four_rolls)\nwin\n\n[1] TRUE"
  },
  {
    "objectID": "03-playing-game1-more.html",
    "href": "03-playing-game1-more.html",
    "title": "3  Playing Game-A a Few Times",
    "section": "",
    "text": "By now you know that Game-A involves rolling a (fair) die four times, and you win if you get at least one six.\nYou’ve also learned that we can write some code to play this game once, determining the winning status:"
  },
  {
    "objectID": "03-playing-game1-more.html#playing-game-a-five-times",
    "href": "03-playing-game1-more.html#playing-game-a-five-times",
    "title": "3  Playing Game-A a Few Times",
    "section": "3.1 Playing Game-A Five Times",
    "text": "3.1 Playing Game-A Five Times\nWe are ready to write code and use it to play Game-A five times\n\nset.seed(133)\n\ndie = 1:6\n\ngame_1 = sample(die, size = 4, replace = TRUE)\ngame_2 = sample(die, size = 4, replace = TRUE)\ngame_3 = sample(die, size = 4, replace = TRUE)\ngame_4 = sample(die, size = 4, replace = TRUE)\ngame_5 = sample(die, size = 4, replace = TRUE)\n\n# win (or lose)?\nwins = c(\n  \"game_1\" = any(game_1 == 6),\n  \"game_2\" = any(game_2 == 6),\n  \"game_3\" = any(game_3 == 6),\n  \"game_4\" = any(game_4 == 6),\n  \"game_5\" = any(game_5 == 6))\n  \n# number of wins\ntotal_wins = sum(wins)\ntotal_wins\n\n[1] 3\n\n# proportion of wins\nprop_wins = sum(wins) / 5\nprop_wins\n\n[1] 0.6\n\n\nAs you can tell, the above code works, but there is a substantial amount of unnecessary repetition. Imagine copying-pasting the sample() command if we wanted to play Game-A 50 times, or 100 times, or 1000 times."
  },
  {
    "objectID": "03-playing-game1-more.html#using-a-for-loop",
    "href": "03-playing-game1-more.html#using-a-for-loop",
    "title": "3  Playing Game-A a Few Times",
    "section": "3.2 Using a for() loop",
    "text": "3.2 Using a for() loop\nThe above code generates the following five games (each game with 4 rolls)\n\n\n\n\n\nFigure 3.2: Five Games\n\n\nTo avoid repeating the same commands multiple times, we can take advantage of loops, for example a for() loop.\nInstead of using individual vectors game_1, game_2, etc, we are going to use a matrix to store the rolls of all games. One option for this matrix is to initialize it in a way that rows correspond to games, while columns correspond to rolls:\n\n\n\n\n\nFigure 3.3: Structure of output matrix with 5 rows and 4 columns.\n\n\nThe idea is to have an iterative process in which each iteration is associated to a game. In other words, at each iteration we play a single game, and we store the output of the rolls in the associated row of the matrix. Here’s how.\n\nset.seed(133)\n\ndie = 1:6\nnumber_games = 5\n\n# initialize output matrix (full of zeros)\ngames = matrix(0, nrow = number_games, ncol = 4)\n\n# each iteration corresponds to a single game\nfor (game in 1:number_games) {\n  games[game, ] = sample(die, size = 4, replace = TRUE)\n}\n\nrownames(games) = paste0(\"game\", 1:number_games)\ncolnames(games) = paste0(\"roll\", 1:4)\ngames\n\n      roll1 roll2 roll3 roll4\ngame1     1     6     4     1\ngame2     5     1     1     6\ngame3     2     5     5     4\ngame4     2     6     6     1\ngame5     4     1     1     1\n\n\nObserve the calls of rownames() and colnames() to assign names to both the rows and the columns of the games matrix. In turn, the row and column names are created with paste0() to generate the necessary character vectors."
  },
  {
    "objectID": "03-playing-game1-more.html#playing-game-a-10-times",
    "href": "03-playing-game1-more.html#playing-game-a-10-times",
    "title": "3  Playing Game-A a Few Times",
    "section": "3.3 Playing Game-A 10 times",
    "text": "3.3 Playing Game-A 10 times\nNow that we have our for() loop in place, we can easily increase the number of games. For instance, consider 10 games. Taking into account the preceding code chunk, all we have to do is change the value of number_games from 5 to 10.\n\nset.seed(133)\n\ndie = 1:6\nnumber_games = 10\n\n# initialize output matrix\ngames = matrix(0, nrow = number_games, ncol = 4)\n\nfor (game in 1:number_games) {\n  games[game, ] = sample(die, size = 4, replace = TRUE)\n}\n\nrownames(games) = paste0(\"game\", 1:number_games)\ncolnames(games) = paste0(\"roll\", 1:4)\ngames\n\n       roll1 roll2 roll3 roll4\ngame1      1     6     4     1\ngame2      5     1     1     6\ngame3      2     5     5     4\ngame4      2     6     6     1\ngame5      4     1     1     1\ngame6      4     3     4     2\ngame7      6     3     1     3\ngame8      4     2     1     1\ngame9      1     6     2     1\ngame10     5     1     6     5\n\n\nAs you can tell, we get a matrix games with 10 rows and 4 columns.\nWe still need to determine the status of each game: do we win? or do we lose?\nConceptually, we could write another for() loop to determine the status of each game: win or lose; something like this\n\n# initialize (logical) vector\nwins = logical(length = number_games)\n\nfor (game in 1:number_games) {\n  wins[game] = any(games[game, ] == 6)\n}\nwins\n\n [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE\n\n\nWhat are we doing in the preceding loop? Simply put, we are applying the any() function to every row of matrix games to see if any of the row elements are equal to six. This is illustrated in the following diagram:\n\n\n\n\n\nFigure 3.4: Diagram depicting the application of any() to all the rows of matrix games.\n\n\nWhile there is nothing conceptually wrong with the above for() loop, we can take advantage of other functions in R to help us write code in a more compact way. Let’s learn about this topic in the next chapter."
  },
  {
    "objectID": "04-apply-function.html",
    "href": "04-apply-function.html",
    "title": "4  Vectorized loops with apply()",
    "section": "",
    "text": "We finished the last chapter writing code that simulates playing Game-A 10 times. For recap purposes, the implemented code is displayed below:\nThe punchline of this piece of code has to do with the for() loop, storing the outputs of each game in the corresponding row of the games matrix.\nAdditionally, we also wrote a second for() loop to determine whether each game—each row in games—had at least one six; this was done with the any() function, and it’s depicted in the following diagram:"
  },
  {
    "objectID": "04-apply-function.html#function-apply",
    "href": "04-apply-function.html#function-apply",
    "title": "4  Vectorized loops with apply()",
    "section": "4.1 Function apply()",
    "text": "4.1 Function apply()\nInstead of writing a loop to see which games are wins, and which games are losses, we can take advantage of a very interesting function called apply(), which R users refer to as a vectorized loop function.\nAs the name indicates, apply() lets you apply a function to the elements of a matrix. The elements of a matrix can be:\n\nits rows: MARGIN = 1\nits columns: MARGIN = 2\nboth (rows & cols): MARGIN = c(1, 2)\n\nFor example, say you want to get the sum() of all the elements in each row of games. Here’s how to do that with apply():\n\n# row sum\napply(X = games, MARGIN = 1, FUN = sum)\n\n game1  game2  game3  game4  game5  game6  game7  game8  game9 game10 \n    12     13     16     15      7     13     13      8     10     17 \n\n\nWe pass three inputs to apply(). The first ingredient is the input matrix, the second ingredient specifies the MARGIN value, and the third ingredient FUN is the function to be applied. MARGIN = 1 means that the function FUN is applied row-by-row.\nHere’s another example. Say you want to obtain the product of all the elements in each column of games. This requires specifying MARGIN = 2 and FUN = prod:\n\n# column product\napply(X = games, MARGIN = 2, FUN = prod)\n\nroll1 roll2 roll3 roll4 \n38400 19440  5760   720 \n\n\nOr what if you want to get the minimum in each row of games? All you have to do is apply() the min function:\n\n# row minimum\napply(X = games, MARGIN = 1, FUN = min)\n\n game1  game2  game3  game4  game5  game6  game7  game8  game9 game10 \n     1      1      2      1      1      2      1      1      1      1"
  },
  {
    "objectID": "04-apply-function.html#anonymous-functions-and-apply",
    "href": "04-apply-function.html#anonymous-functions-and-apply",
    "title": "4  Vectorized loops with apply()",
    "section": "4.2 Anonymous functions and apply()",
    "text": "4.2 Anonymous functions and apply()\nSometimes, there is no built-in function to be used for the argument FUN. For instance, say you want to obtain the range of each row, that is, the maximum minus the minimum. R has a range() function but it does not return a single value, it just gives you the min() and the max() of an input vector:\n\ngame_1 = c(1, 6, 4, 1)\nrange(game_1)\n\n[1] 1 6\n\n\nIf you want the range, you need to compute the max() minus the min()\n\ngame_1 = c(1, 6, 4, 1)\nrange_1 = max(game_1) - min(game_1)\nrange_1\n\n[1] 5\n\n\nBecause R does not have a built-in function that returns the range, we need to provide this function to the FUN argument of apply(). When the function to be provided is fairly simple, we can create an anonymous function inside apply(), here’s how we do it:\n\n# row ranges (with anonymous function)\napply(\n  X = games, \n  MARGIN = 1, \n  FUN = function(x) max(x) - min(x))\n\n game1  game2  game3  game4  game5  game6  game7  game8  game9 game10 \n     5      5      3      5      3      2      5      3      5      5 \n\n\nThe reason why the provided function to the argument FUN is called an anonymous function is because the created function has no name.\nAn alternative option is to first create a function outside apply(), and then pass this function like any other function. This alternative is often preferred when the body of the function to be passed to apply() involves several lines of code.\nFor example, in the following code chunk we create a function vector_range()—that computes the statistical range—and then we pass this function to apply() in order to get the range in each row of the matrix games:\n\n# auxiliary function to compute range\nvector_range = function(x) {\n  max(x) - min(x)\n}\n\n# row ranges\napply(\n  X = games, \n  MARGIN = 1, \n  FUN = vector_range)\n\n game1  game2  game3  game4  game5  game6  game7  game8  game9 game10 \n     5      5      3      5      3      2      5      3      5      5 \n\n\n\n4.2.1 Number of wins with apply()\nLet’s go back to the task of finding which games are wins. Because there’s no default function that computes if any() element of a vector is equal to six, we need to create an anonymous function for the FUN argument:\n\nwins = apply(\n  X = games, \n  MARGIN = 1,\n  FUN = function(x) any(x == 6))\n\nwins\n\n game1  game2  game3  game4  game5  game6  game7  game8  game9 game10 \n  TRUE   TRUE  FALSE   TRUE  FALSE  FALSE   TRUE  FALSE   TRUE   TRUE \n\n\nWe can now compute the proportion of wins:\n\nprop_wins = sum(wins) / number_games\nprop_wins\n\n[1] 0.6"
  },
  {
    "objectID": "05-playing-game1-100times.html",
    "href": "05-playing-game1-100times.html",
    "title": "5  Playing Game-A 100 times",
    "section": "",
    "text": "With all the coding elements that we have discussed so far, it’s time to play Game-A 100 times, and see what the proportion of wins turns out to be:\nIn this particular simulation of 100 games, we end up with a 0.5 proportion of wins. In other words, 50 percent of the games are wins, and the other 50 percent of the games are losses."
  },
  {
    "objectID": "05-playing-game1-100times.html#computing-cumulative-gains",
    "href": "05-playing-game1-100times.html#computing-cumulative-gains",
    "title": "5  Playing Game-A 100 times",
    "section": "5.1 Computing Cumulative Gains",
    "text": "5.1 Computing Cumulative Gains\nTo make things more interesting, let’s assume that you are paid $1 if you win a game, but also that you pay $1 if you lose a game. That is:\n\ngain 1 if you win a game\ngain -1 if you lose a game\n\nThis means that we need to create another object to store this “gains” information. This can be done in different ways. One option is to initialize a vector gains of length number_games, and set its elements to -1. Then use the logical vector wins to do logical subsetting and switch to 1 the elements matching the TRUE values in wins, like this:\n\n# vector of gains\ngains = rep(-1, number_games)  # initialize with all -1 elements\ngains[wins] = 1                # switch to +1 for every win\n\nThe vector gains is a numeric vector containing as many 1’s as wins, and as many -1 as losses:\n\ntable(wins)\n\nwins\nFALSE  TRUE \n   50    50 \n\n\nMore interestingly, we can use cumsum() to obtain the cumulative addition of all elements in wins. The output vector, cumulative_gains, will contain the sequence of cumulative gains along the 100 games.\n\n# cumulative gains\ncumulative_gains = cumsum(gains)\n\nhead(cumulative_gains, n = 10)\n\n [1]  1  2  1  0 -1 -2 -1 -2 -3 -4\n\n\nAs you can tell from this output, the first game is a win, as well as the second one. But then, we get a decreasing sequence with the next four elements in cumulative_gains: 1 0 -1 -2, indicating that games 3 to 6 are consecutive losses."
  },
  {
    "objectID": "05-playing-game1-100times.html#plotting-cumulative-gains",
    "href": "05-playing-game1-100times.html#plotting-cumulative-gains",
    "title": "5  Playing Game-A 100 times",
    "section": "5.2 Plotting Cumulative Gains",
    "text": "5.2 Plotting Cumulative Gains\nIt would be nice to visualize the sequence of wins and losses using the vector of cumulative gains cumulative_gains. So let’s see how to get some plots using base \"graphics\" functions, as well as \"ggplot2\" functions.\n\n5.2.1 Cumulative Gains with plot()\nUsing traditional \"graphics\" functions, we can create a line graph with plot(). In the x-axis we pass a sequence vector of games; as for the y-axis we pass the cumulative_gains vector.\n\nplot(1:number_games, cumulative_gains, type = 'l',\n     xlab = \"games\", ylab = \"cumulative gain\", las = 1,\n     lwd = 1.5, col = \"#318BEC\")\nabline(h = 0, col = \"gray70\", lty = 2)\n\n\n\n\n\n\n\n\nObserve where the blue line ends at game 100: exactly at a y-axis value of zero. Basically, in this series of 100 games, you didn’t gain any money, but you didn’t lose either.\n\n\n5.2.2 Cumulative Gains with ggplot2\nWhat if you prefer to make a graphic with \"ggplot2\" functions instead of using the traditional base plot() approach? No problem, this is also possible.\nWe are assuming that you have loaded the package \"tidyverse\" which contains \"ggplot2\".\n\nlibrary(tidyverse)   # which contains ggplot2\n\nTo make graphics with ggplot(), we first need to assemble the data to be plotted into a data frame. One way to create this table is as follows:\n\ntbl = data.frame(\n  game = 1:number_games,\n  gain = gains,\n  cumulative_gain = cumsum(gains)\n)\n\nhead(tbl)\n\n  game gain cumulative_gain\n1    1    1               1\n2    2    1               2\n3    3   -1               1\n4    4   -1               0\n5    5   -1              -1\n6    6   -1              -2\n\n\nHaving the appropriate data in a data frame object tbl, we can now proceed to make a line graph with the number game in the x-axis, and the cumulative gain in the y-axis.\n\nggplot(data = tbl, aes(x = game, y = cumulative_gain)) + \n  geom_hline(yintercept = 0, color = \"gray70\") +\n  geom_line(color = \"#318BEC\", linewidth = 1) +\n  labs(x = \"games\", \n       y = \"cumulative gain\", \n       title = \"Playing Game-A 100 times\",\n       subtitle = \"Sequence of cumulative gains\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n5.2.3 Animated ggplot graphic\nFor your amusement, it is also possible to make an animated ggplot graphic. This requires the companion package \"gganimate\"\n\nlibrary(gganimate)\n\n# gganimate may also need:\n# library(gifski)   # for gif output\n# library(av)       # for video output\n\nFor convenience purposes, it’s better if we assign the graphic to an object, e.g. static_plot, and then we add a transition layer with one of the transition_() functions. In this example we are going to use the transition_reveal() function, specifying game as the variable in the data tbl that needs to be taken into account to create the frames of the animation.\n\n# ggplot object\nstatic_plot = ggplot(data = tbl, aes(x = game, y = cumulative_gain)) + \n  geom_hline(yintercept = 0, color = \"gray70\") +\n  geom_line(color = \"#318BEC\", linewidth = 1) +\n  labs(x = \"games\", \n       y = \"cumulative gain\", \n       title = \"Playing Game-A 100 times\",\n       subtitle = \"Sequence of cumulative gains\") +\n  theme_minimal()\n\n# animation\nanimated_plot = static_plot +\n  transition_reveal(game)\n\nanimate(animated_plot)\n\n\n\n\n\n\nFigure 5.1: Game-A 100 times\n\n\nTo save the animated plot into a gif file, you use anim_save(), for example:\n\n# save gif in working directory\nanim_save(\n  filename = \"Playing-Game-A-100-times.gif\", \n  animation = animated_plot,\n  height = 5, \n  width = 7, \n  units = \"in\",\n  res = 200)"
  },
  {
    "objectID": "06-several-simulations.html",
    "href": "06-several-simulations.html",
    "title": "6  Running Various Simulations",
    "section": "",
    "text": "A single series of 100 games may not be enough to fully understand the probability behavior of Game-A. So let’s see how to run various simulations, all of them involving playing 100 games.\nLet’s start small. Meaning, let’s begin with a handful of games, and a few simulations. This will allow us to get a better idea of the objects and commands we need to use in order to later generalize things with more games and simulations.\nOur starting point will involve 3 simulations, each one consisting of 5 games as illustrated in the picture below.\nHere’s some naive code to run these simulations. We are momentarily considering this piece of code to get a high-level intuition of the things we might need later to write more efficient commands.\nThis piece of code has a lot of unnecessary redundancy. But let’s ignore this fact for a second. In each simulation, we create a matrix games_sim to store the rolls of each game. Then we use apply() to determine which games are wins (wins_sim), and finally we calculate the proportion of wins (prop_wins_sim).\nIf you inspect the vectors wins_sim1, wins_sim2, and wins_sim3, you’ll see that these are of \"logical\" data-type. TRUE means that a given game is a win, whereas FALSE means lose.\nAlternatively, instead of dealing with the logical vectors wins_sim, we can convert their values into numbers: 1 instead of TRUE, and -1 instead of FALSE. Why do we need this change from logical to numbers? Quick answer, you don’t really need it. But as we’ll see, working with 1 and -1 is more convenient later down the road when we calculate cumulative gains.\nThe diagram below depicts this idea of storing the end result of each game into 1 (win) or -1 (lose), for every simulation:"
  },
  {
    "objectID": "06-several-simulations.html#embedded-for-loops",
    "href": "06-several-simulations.html#embedded-for-loops",
    "title": "6  Running Various Simulations",
    "section": "6.1 Embedded for() loops",
    "text": "6.1 Embedded for() loops\nLet’s take the preceding naive code and try to make it more compact. We are going to use embedded for() loops: one of them to take care of the simulations, and the other one to take care of the games.\nThe idea is to iterate through each simulation: 1, 2, and 3. And then, in a given simulation, we iterate through each game: 1, 2, 3, 4, and 5.\n\nset.seed(753)\n\n# main inputs\ndie = 1:6\nnumber_games = 5\nnumber_sims = 3\n\n# matrix to store simulation outputs\nsimulations = matrix(0, nrow = number_games, ncol = number_sims)\n\n# 1st loop) iterate through each simulation\nfor (sim in 1:number_sims) {\n  games = matrix(0, nrow = number_games, ncol = 4)\n  \n  # 2nd loop) iterate through each game\n  for (game in 1:number_games) {\n    games[game, ] = sample(die, size = 4, replace = TRUE)\n  }\n  any_sixes = apply(games, 1, function(x) any(x == 6))\n  simulations[ ,sim] = ifelse(any_sixes, 1, -1)\n}\n\nrownames(simulations) = paste0(\"game\", 1:number_games)\ncolnames(simulations) = paste0(\"sim\", 1:number_sims)\nsimulations\n\n      sim1 sim2 sim3\ngame1    1   -1   -1\ngame2    1    1    1\ngame3   -1   -1    1\ngame4   -1   -1    1\ngame5   -1   -1    1\n\n\nWhat’s going on with this code? Before starting the iterations, we create a matrix simulations which will store the numeric values of all games, and all simulations. The rows of this matrix are associated to the games, and the columns are associated to the simulations. At the end of the iterative process, the cells of this matrix will be populated with either 1 (win game) and -1 (lose game).\nThe first for() loop—the outer loop—iterates through the simulations. At the beginning of each simulation, an auxiliary games matrix is initialized, which then gets populated in the embedded for() loop. This second for() loop—the inner loop—iterates through the games, obtaining the rolls of the five games. Right after the games are completed in the inner loop, we use apply() to determine which games are wins (i.e. have at least one 6), and then we convert the TRUE’s and FALSE’s into 1 and -1, respectively, by using ifelse(). This numeric vector is stored in the corresponding column of the simulations matrix.\nHaving obtained the matrix simulations, we then proceed to count the number of wins total_wins (see code below). Notice the use of apply() to count the number of wins for each column of simulations. The last step involves computing the proportion of wins prop_wins:\n\ntotal_wins = apply(simulations, 2, function(x) sum(x==1))\nprop_wins = total_wins / number_games\nprop_wins\n\nsim1 sim2 sim3 \n 0.4  0.2  0.8"
  },
  {
    "objectID": "07-even-more-simulations.html",
    "href": "07-even-more-simulations.html",
    "title": "7  Running Even More Simulations",
    "section": "",
    "text": "In the previous section we discussed one possible strategy to run three simulations, each one consisting of five games. From the programming point of view, the core of this strategy is the utilization of embedded for() loops.\nNow, three simulations and five games is obviously not enough. To get a better feeling of the probability of winning Game-A—approximated by the proportion of wins—we need to take things to the next level: with more simulations, and many more games.\nExactly how many more simulations, and how many more games? There is no definitive answer to this question. Obviously the more games and simulations, the better. To keep things simple, but also fairly realistic, I think 100 simulations and 1000 games is a reasonable choice. The following diagram illustrates what the games matrix (of 1000 rows and 4 columns) for each of the 100 simulations could look like, and also de derived matrix simulations having 1000 rows and 100 columns:\nThe following code uses 1000 games and 100 simulations. This allows us to play Game-A for a total of \\(1,000 \\times 100 = 100,000\\) times. With this many games, we can safely calculate the average proportion of wins, and use this value to estimate the probability of winning Game-A:\nAs you can tell, the average proportion of wins turns out to be 0.51674 which is pretty close to the theoretical probability of winning Game-A\n\\[\\begin{align*}\nProb(\\text{at least one six in 4 rolls}) &= 1 - Prob(\\text{no six in 4 rolls}) \\\\\n&= 1 - \\left( \\frac{5}{6} \\right)^4 \\\\\n&= 0.517747\n\\end{align*}\\]\nOf course, if you change the random seed and rerun this simulation, you will very likely obtain a slightly different proportion of wins. But still close enough to the actual theoretical probability of winning Game-A."
  },
  {
    "objectID": "07-even-more-simulations.html#graphing-cumulative-gains",
    "href": "07-even-more-simulations.html#graphing-cumulative-gains",
    "title": "7  Running Even More Simulations",
    "section": "7.1 Graphing Cumulative Gains",
    "text": "7.1 Graphing Cumulative Gains\nLike in chapter Playing Game-A 100 times, let’s visualize what’s going on with the sequence of cumulative gains—assuming you gain $1 if you win a game, and you gain -$1 if you lose a game.\n\n7.1.1 Plotting the first simulation\nThe main data object that we have is the matrix simulations. This is a 1000 by 100 matrix. So let’s begin with a ggplot to visualize the cumulative gains of the games in the first simulation. That is, the games in the first column of this matrix.\nBecause we are interested in making a graph with \"ggplot2\", the first step consists of creating a data frame. Perhaps the simplest thing to do is to assemble a 2-column table dat_sim1: column games for the number of games, and another column gain for the cumulative gain in the games of the first simulation.\n\ndat_sim1 = data.frame(\n  games = 1:number_games,\n  gain = cumsum(simulations[ ,1])\n)\n\nhead(dat_sim1, n = 10)\n\n       games gain\ngame1      1    1\ngame2      2    2\ngame3      3    1\ngame4      4    0\ngame5      5   -1\ngame6      6   -2\ngame7      7   -1\ngame8      8   -2\ngame9      9   -3\ngame10    10   -4\n\n\nThe next step is to pass dat_sim1 to ggplot() and friends to obtain a timeline, very similar to the one obtain in section Cumulative Gains with ggplot2\n\nggplot(data = dat_sim1, aes(x = games, y = gain)) +\n  geom_hline(yintercept = 0, color = \"gray50\") +\n  geom_line() + \n  theme_minimal() +\n  labs(title = \"First Simulation of Game-A\",\n       subtitle = \"Cumulative gains in 1000 games\")\n\n\n\n\n\n\n\n\n\n\n7.1.2 Plotting the first four simulations\nLet’s take a further step by considering the cumulative gains in the first four simulations.\nBecause we need to obtain the cumulative gains in each simulation, it’s better if we apply() the function cumsum() on each column of the matrix simulations. This will produce another 1000-by-100 matrix that we’ll name cum_gain_prog:\n\n# 1000-by-100 matrix of cumulative gains \ncum_gain_prog = apply(simulations, 2, cumsum)\n\nAs usual, to call ggplot() we must have the input data into a data.frame (or a tibble) object. Here’s one way to create a table dat_4sims containing three columns: 1) column games, 2) gain containing the cumulative gain, and 3) simulation for the associated simulation.\n\n# table with first four simulations\ndat_4sims = data.frame(\n  games = rep(1:number_games, times = 4),\n  gain = as.vector(cum_gain_prog[ ,1:4]),\n  simulation = rep(paste0(\"simulation-\", 1:4), each = number_games)\n)\n\nNow we are ready to graph the timelines for the first four simulations. In this case, we’ll use facets to better distinguish between each simulation:\n\nggplot(data = dat_4sims, aes(x = games, y = gain)) +\n  geom_hline(yintercept = 0, color = \"gray70\") +\n  geom_line() + \n  facet_wrap(~ simulation) + \n  theme_light() +\n  labs(title = \"First 4 Simulations of Game-A\",\n       subtitle = \"Cumulative gains in 1000 games\")\n\n\n\n\n\n\n\n\nNotice the different trends in each simulation. The 1000 games played in simulations 1, 2, and 4 resulted in a positive gain. In contrast, the final gain in simulation 3 turned out to be negative.\n\n\n7.1.3 Plotting all simulations\nOut of curiosity let’s graph the cumulative gains of all 100 simulations.\n\n# converting matrix into data.frame\ndat_cum_gain = as.data.frame(cum_gain_prog)\ndat_cum_gain$games = 1:number_games\n\n# reshaping table into \"long\" or \"tall\" format\ntbl_cum_gain = pivot_longer(\n  dat_cum_gain,\n  cols = starts_with(\"sim\"),\n  names_to = \"simulation\", \n  values_to = \"gain\")\n\nWe can now proceed with ggplot()\n\nggplot(data = tbl_cum_gain, aes(x = games, y = gain)) +\n  geom_line(aes(group = simulation), \n            color = \"gray50\", alpha = 0.3, linewidth = 0.3) + \n  geom_hline(yintercept = 0, color = \"gray50\") +\n  theme_minimal() +\n  labs(title = \"100 Simulations of Game-A\",\n       subtitle = \"Cumulative gains in 1000 games\")\n\n\n\n\n\n\n\n\nAs you can tell, there is a lot going on in this graphic. Essentially, we have 100 lines (each one corresponds to a given simulation), and a considerable amount of overlapping between all of them. Despite adding some transparency to the lines—with the alpha argument inside geom_line()—it’s hard to follow the path of any single line.\nOne thing to pay attention to is that the majority of lines are above the horizontal zero-baseline. But not all of them, as reflected by a small proportion of lines that end up below the zero-baseline. Nevertheless, this plot allows us to see an undeniable fact: in the long run, playing Game-A gives you a decent chance of ending with a positive gain. No wonder why Chevalier De Méré was able to make some money with this game of chance."
  }
]